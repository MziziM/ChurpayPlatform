You are a senior platform engineer. Apply ALL changes below to the current repo in ONE pass. 
Do NOT ask questions. If paths differ, SEARCH and adjust. If a file is missing, CREATE it.
Assume sensible defaults. After changes, run the app and confirm GET /health returns { ok: true }.

=====================================
1) Install required dependencies
=====================================
Run:
- npm i helmet cors express-rate-limit pino-http zod
- npm i -D eslint prettier @types/express-rate-limit @types/cors @types/helmet

=====================================
2) Replace server entry (security hardened)
=====================================
Open/replace exact content of: server/index.ts
---BEGIN FILE: server/index.ts---
import express, { type Request, Response, NextFunction } from "express";
import session from "express-session";
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import pinoHttp from "pino-http";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { protectCoreEndpoints, validateFeeStructure } from "./codeProtection";

const app = express();

// Logging (redact secrets)
app.use(pinoHttp({ redact: ["req.headers.authorization", "req.body.password", "req.body.passphrase"] }));

// Trust proxy when deployed behind Render/Replit/NGINX
if (process.env.NODE_ENV === "production") {
  app.set("trust proxy", 1);
}

// Security headers
app.use(helmet({
  contentSecurityPolicy: false, // tighten later with CSP allowlist
  crossOriginEmbedderPolicy: true,
  frameguard: { action: "deny" },
}));

// Strict JSON parsing
app.use(express.json({ limit: "1mb" }));
app.use(express.urlencoded({ extended: false, limit: "1mb" }));

// CORS (restrict to known frontend URL)
const allowedOrigin = process.env.FRONTEND_URL || "http://localhost:5173";
app.use(cors({
  origin: allowedOrigin,
  credentials: true,
  methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type","Authorization"],
}));

// Global rate limit
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 300,
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// Session configuration for super admin auth
app.use(session({
  secret: process.env.SESSION_SECRET as string,
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    sameSite: "lax",
    secure: process.env.NODE_ENV === "production",
    maxAge: 1000 * 60 * 60 * 8, // 8h
  },
  name: "churpay.sid",
}));

// Pre-flight health check
app.get("/health", (_req: Request, res: Response) => res.json({ ok: true }));

// Validate protected constants & fee structure on boot
validateFeeStructure();
protectCoreEndpoints(app);

// Register API routes
registerRoutes(app);

// Static assets & Vite in dev
if (process.env.NODE_ENV !== "production") {
  setupVite(app);
} else {
  serveStatic(app);
}

// Error handler
app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  log("error", err);
  const status = err.status || 500;
  res.status(status).json({ error: "Internal Server Error" });
});

// Start server
const port = parseInt(process.env.PORT || "5000", 10);
app.listen(port, "0.0.0.0", () => log(`serving on port ${port}`));
---END FILE: server/index.ts---

=====================================
3) Add PayFast signature verification helper
=====================================
Create file: server/payfast.ts
---BEGIN FILE: server/payfast.ts---
import crypto from "crypto";
import { Request } from "express";

type Dict = Record<string, string>;

/** Build signature per PayFast docs */
export function buildSignature(params: Dict, passphrase?: string) {
  const qs = Object.keys(params)
    .filter((k) => k !== "signature" && params[k] !== undefined && params[k] !== null)
    .sort()
    .map((k) => `${k}=${encodeURIComponent(params[k]).replace(/%20/g, "+")}`)
    .join("&");
  const base = passphrase ? `${qs}&passphrase=${encodeURIComponent(passphrase)}` : qs;
  return crypto.createHash("md5").update(base).digest("hex");
}

/** Extract POST fields to strings */
export function extractParams(req: Request): Dict {
  const out: Dict = {};
  const body = req.body || {};
  for (const [k, v] of Object.entries(body)) {
    out[k] = Array.isArray(v) ? String(v[0]) : String(v ?? "");
  }
  return out;
}

/** Validate PayFast IPN signature & basic source check */
export function validatePayFastIPN(req: Request) {
  const params = extractParams(req);
  const receivedSig = (params["signature"] || "").toLowerCase();
  const passphrase = process.env.PAYFAST_MERCHANT_KEY;
  if (!passphrase) throw new Error("Missing PAYFAST_MERCHANT_KEY");

  const computed = buildSignature(params, passphrase).toLowerCase();
  if (receivedSig !== computed) throw new Error("Invalid PayFast signature");

  // Basic IP presence (tighten with allowlist later)
  const ip = (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() || req.socket.remoteAddress || "";
  if (!ip) throw new Error("Unable to determine source IP");

  return { params, ip };
}
---END FILE: server/payfast.ts---

=====================================
4) Patch PayFast notify handler (verify + idempotency + amount check)
=====================================
In server/routes.ts:
- Add at top:  import { validatePayFastIPN } from "./payfast";
- Locate the POST handler for "/api/payfast/notify". REPLACE the handler body with:

---BEGIN PATCH SNIPPET---
app.post("/api/payfast/notify", async (req, res) => {
  try {
    const { params } = validatePayFastIPN(req); // throws if invalid
    const {
      m_payment_id,           // our internal ID
      merchant_id,
      amount_gross,
      payment_status,
      signature,
      currency,
    } = params;

    if (process.env.PAYFAST_MERCHANT_ID && merchant_id && merchant_id !== process.env.PAYFAST_MERCHANT_ID) {
      throw new Error("mismatched merchant_id");
    }

    // Load expected transaction (adjust imports/selectors if different)
    const { db } = await import("./db");
    const { transactions } = await import("@shared/schema");
    const { eq } = await import("drizzle-orm");
    const txRows = await db.select().from(transactions).where(eq(transactions.id, m_payment_id)).limit(1);
    const tx = txRows[0];
    if (!tx) throw new Error("unknown m_payment_id");
    if (tx.status === "completed") return res.status(200).send("OK"); // idempotent

    const expected = Number(tx.amount);
    const got = Number(amount_gross);
    if (!Number.isFinite(expected) || Math.abs(got - expected) > 0.01) {
      throw new Error("amount mismatch");
    }

    const newStatus =
      String(payment_status).toUpperCase() === "COMPLETE" ? "completed" :
      String(payment_status).toUpperCase() === "CANCELLED" ? "cancelled" : "failed";

    await db.update(transactions)
      .set({
        status: newStatus,
        gateway: "payfast",
        currency: currency || "ZAR",
        ipnSignature: signature || null,
        processedAt: new Date(),
      })
      .where(eq(transactions.id, m_payment_id));

    return res.status(200).send("OK");
  } catch (e) {
    console.error("PayFast notify verification failed:", e);
    return res.status(400).send("Invalid");
  }
});
---END PATCH SNIPPET---

=====================================
5) Route-level rate limits for sensitive endpoints
=====================================
In server/routes.ts (near your route registrations), add:

---BEGIN PATCH SNIPPET---
import rateLimit from "express-rate-limit";
const webhookLimiter = rateLimit({ windowMs: 60_000, max: 60 });     // 60 per minute
const authLimiter    = rateLimit({ windowMs: 15*60_000, max: 50 });  // 50 per 15 mins

// apply to specific routes (ensure order is correct in your file)
app.post("/api/payfast/notify", webhookLimiter, /* existing handler above will remain */);
app.post("/api/auth/login", authLimiter, /* your login handler */);
---END PATCH SNIPPET---

(If the app/router is split, attach these to the correct router instance.)

=====================================
6) zod validation example (apply to donate/create routes)
=====================================
Where you accept donation creation requests, wrap with a zod validator:

---BEGIN PATCH SNIPPET---
import { z } from "zod";
const DonateSchema = z.object({
  churchId: z.string().min(1),
  amount: z.coerce.number().positive().max(100000),
  donationType: z.enum(["tithe","offering","project"]),
  note: z.string().max(200).optional(),
});

app.post("/api/donate", (req, res, next) => {
  try { req.body = DonateSchema.parse(req.body); next(); }
  catch { return res.status(400).json({ error: "Invalid payload" }); }
}, donateHandler);
---END PATCH SNIPPET---

(Adjust route name and fields to your actual create-donation route.)

=====================================
7) Drizzle schema extensions (idempotency + audit)
=====================================
Open shared/schema.ts and ENSURE transactions table has these fields (add if missing):

---BEGIN PATCH SNIPPET---
// Example fields for transactions table (adjust to your dialect helpers)
export const transactions = pgTable("transactions", {
  id: text("id").primaryKey(), // m_payment_id you generate
  amount: numeric("amount", { precision: 12, scale: 2 }).notNull(),
  currency: text("currency").default("ZAR"),
  status: text("status").$type<"pending"|"completed"|"failed"|"cancelled">().notNull().default("pending"),
  gateway: text("gateway"),
  paymentRef: text("payment_ref"),
  ipnSignature: text("ipn_signature"),
  createdAt: timestamp("created_at").defaultNow(),
  processedAt: timestamp("processed_at"),
});
---END PATCH SNIPPET---

After updating schema, run:
- npm run db:push

=====================================
8) Add .env.example (root) for team onboarding
=====================================
Create/replace file: .env.example
---BEGIN FILE: .env.example---
# ChurPay - Environment variables (example)
NODE_ENV=development
PORT=5000
DATABASE_URL=postgres://user:pass@host:5432/churpay
SESSION_SECRET=change_this_to_a_long_random_string
FRONTEND_URL=http://localhost:5173
PAYFAST_MERCHANT_ID=
PAYFAST_MERCHANT_KEY=
PRIVATE_OBJECT_DIR=./private_objects
PUBLIC_OBJECT_SEARCH_PATHS=./public
EMAIL_USER=
EMAIL_PASS=
---END FILE: .env.example---

=====================================
9) ESLint + Prettier base configs (root)
=====================================
Create file: .eslintrc.json
Content:
{
  "env": { "browser": true, "es2021": true, "node": true },
  "extends": ["eslint:recommended"],
  "parserOptions": { "ecmaVersion": 2021, "sourceType": "module" },
  "rules": { "no-unused-vars": ["warn", { "argsIgnorePattern": "^_" }] }
}

Create file: .prettierrc
Content:
{ "semi": true, "singleQuote": false, "printWidth": 100 }

Add/ensure package.json scripts:
- "lint": "eslint ."
- "format": "prettier -w ."
- "check": "tsc --noEmit"

=====================================
10) Run & verify
=====================================
- Ensure Secrets are set in Replit: SESSION_SECRET, DATABASE_URL, FRONTEND_URL, PAYFAST_MERCHANT_ID, PAYFAST_MERCHANT_KEY
- Start dev: npm run dev
- After boot, GET /health must return { ok: true }

Now test IPN failure (should be 400):
curl -X POST "http://localhost:5000/api/payfast/notify" \
 -H "Content-Type: application/x-www-form-urlencoded" \
 -d "m_payment_id=TEST123&amount_gross=10.00&payment_status=COMPLETE&signature=badsignature"

Expected: HTTP 400 with "Invalid". If it returns OK, re-apply the handler patch.

=====================================
11) Output to me
=====================================
Reply with:
- List of files created/updated
- Result of GET /health (status + JSON)
- Result of the curl IPN test (status + body)
- Any errors you fixed automatically (if any)